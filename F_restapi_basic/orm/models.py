import uuid
from django.db import models


from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from datetime import date
from typing import Optional, TypedDict, List

# from django.contrib.auth.models import User
from django.contrib.auth import get_user_model

User = get_user_model()


class PeakSalesDay(TypedDict):
    date: date
    total_sold: int


class OrderedProductType(TypedDict):
    product_id: uuid.UUID
    product_name: str
    product_price: float
    product_quantity: int
    product_subtotal: float


class Category(models.Model):
    id = models.UUIDField(
        primary_key=True, default=uuid.uuid4, editable=False, unique=True
    )
    name = models.CharField(max_length=100)
    parent = models.ForeignKey(
        "self",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="subcategories",
    )

    def __str__(self):
        return self.name if not self.parent else f"{self.parent} -> {self.name}"


class Product(models.Model):
    id = models.UUIDField(
        primary_key=True, default=uuid.uuid4, editable=False, unique=True
    )
    name = models.CharField(max_length=100)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.PositiveIntegerField()
    category = models.ForeignKey(
        Category, on_delete=models.CASCADE, related_name="products"
    )

    class Status(models.TextChoices):
        ACTIVE = "active", "Active"
        INACTIVE = "inactive", "Inactive"

    status = models.CharField(
        max_length=10, choices=Status.choices, default=Status.ACTIVE
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

    def add_stock(self, quantity):
        """Increase stock."""
        self.stock += quantity
        self.save()

    def reduce_stock(self, quantity):
        """Decrease stock."""
        if quantity > self.stock:
            raise ValueError("Insufficient stock!")
        self.stock -= quantity
        self.save()

    def deactivate(self):
        """Mark product as inactive."""
        self.status = Product.Status.INACTIVE
        self.save()

    def activate(self):
        """Mark product as active."""
        self.status = Product.Status.ACTIVE
        self.save()

    # --- Analytics ---
    @property
    def total_units_sold(self) -> int:
        """Calculate the total number of units sold for this product."""
        return (
            self.order_items.aggregate(total_sold=models.Sum("quantity"))["total_sold"]
            or 0
        )

    @property
    def total_revenue(self) -> float:
        """Calculate the total revenue generated by this product."""
        return (
            self.order_items.aggregate(
                total_revenue=models.Sum(
                    models.F("quantity") * models.F("product__price")
                )
            )["total_revenue"]
            or 0
        )

    @property
    def total_orders(self) -> int:
        """Count the total number of orders containing this product."""
        return self.order_items.values("order").distinct().count()

    @property
    def average_quantity_per_order(self) -> float:
        """Calculate the average quantity of the product per order."""
        total_orders = self.total_orders  # Access the property as an attribute
        total_units = self.total_units_sold
        return total_units / total_orders if total_orders > 0 else 0

    @property
    def days_since_last_sale(self) -> Optional[int]:
        """Calculate the number of days since the product was last sold."""

        last_order = self.order_items.order_by("-order__created_at").first()
        if last_order:
            return (date.today() - last_order.order.created_at.date()).days
        return None

    @property
    def peak_sales_day(self) -> Optional[PeakSalesDay]:
        """Determine the day with the highest sales volume."""
        peak_day = (
            self.order_items.values("order__created_at__date")
            .annotate(total_sold=models.Sum("quantity"))
            .order_by("-total_sold")
            .first()
        )
        if peak_day:
            return {
                "date": peak_day[
                    "order__created_at__date"
                ],  # Rename to a user-friendly key
                "total_sold": peak_day["total_sold"],
            }
        return None


class Order(models.Model):
    id = models.UUIDField(
        primary_key=True, default=uuid.uuid4, editable=False, unique=True
    )
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="orders")
    shipping_address = models.TextField()

    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        SHIPPED = "shipped", "Shipped"
        DELIVERED = "delivered", "Delivered"
        CANCELLED = "cancelled", "Cancelled"

    status = models.CharField(
        max_length=20, choices=Status.choices, default=Status.PENDING
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Order {self.id} by {self.user.username} ({self.status})"

    @property
    def total_price(self) -> float:
        """Calculate the total price of the order."""
        return sum(item.item_subtotal for item in self.order_items.all())

    @property
    def ordered_products(self) -> List[OrderedProductType]:
        """List all products in the order."""
        return [
            {
                "product_id": item.product.id,
                "product_name": item.product.name,
                "product_price": item.product.price,
                "product_quantity": item.quantity,
                "product_subtotal": item.item_subtotal,
            }
            for item in self.order_items.all()
        ]

    def add_product(self, product, quantity):
        """Add a product to the order."""
        if product.stock < quantity:
            raise ValueError("Insufficient stock for the product!")
        order_item, created = OrderItem.objects.get_or_create(
            order=self, product=product, defaults={"quantity": quantity}
        )
        if not created:
            order_item.quantity += quantity
            order_item.save()
        product.reduce_stock(quantity)

    def remove_product(self, product):
        """Remove a product from the order."""
        try:
            order_item = self.order_items.get(product=product)
            product.add_stock(order_item.quantity)
            order_item.delete()
        except OrderItem.DoesNotExist:
            raise ValueError("Product not in order.")

    def change_status(self, status):
        """Change the order status."""
        if status not in dict(Order.Status.choices):
            raise ValueError("Invalid status.")
        self.status = status
        self.save()


class OrderItem(models.Model):
    order = models.ForeignKey(
        Order, on_delete=models.CASCADE, related_name="order_items"
    )
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name="order_items"
    )
    quantity = models.PositiveIntegerField()

    @property
    def item_subtotal(self) -> float:
        """Calculate the subtotal for this item."""
        return self.product.price * self.quantity

    def __str__(self):
        return f"Order {self.order.id} - {self.product.name} x {self.quantity}"


""" 
In a true `Many-to-Many` relationship:

- A product can belong to many orders.
- An order can include many products.
- This relationship would typically be modeled using a Django `ManyToManyField`, which automatically creates an intermediary table to manage the many-to-many relationships.


Here, `OrderItem` acts as an explicit intermediary model for a many-to-many relationship between `Order` and `Product`. It allows you to add extra data (e.g., quantity) that wouldn't be possible in an implicit Many-to-Many relationship.
"""


class Cart(models.Model):
    id = models.UUIDField(
        primary_key=True, default=uuid.uuid4, editable=False, unique=True
    )
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="cart")

    class Status(models.TextChoices):
        ACTIVE = "active", "Active"
        ABANDONED = "abandoned", "Abandoned"

    status = models.CharField(
        max_length=20, choices=Status.choices, default=Status.ACTIVE
    )

    def __str__(self):
        return f"{self.user.username}'s Cart"

    @property
    def total_price(self):
        """
        Calculate the total price of the cart.
        """
        return sum(item.total_price for item in self.cart_items.all())


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name="cart_items")
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField()

    @property
    def total_price(self):
        return self.product.price * self.quantity

    def __str__(self):
        return f"{self.cart.user.username} - {self.product.name} x {self.quantity}"


class Review(models.Model):
    id = models.UUIDField(
        primary_key=True, default=uuid.uuid4, editable=False, unique=True
    )
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="reviews")
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.UUIDField()
    content_object = GenericForeignKey()
    text = models.TextField()
    rating = models.PositiveIntegerField()

    def __str__(self):
        return f"Review by {self.user.username} ({self.rating}/5)"
